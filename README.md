# Cooking
Nous avons voulu segmenter la base de données comme nous avons pensé notre code afin de nous y retrouver plus facilement. On y retrouve nos trop principales entités Clients, Recette et Produits. Tout le reste des entités et associations ont été crée pour faciliter la compréhension et mieux ordonner les données. Afin de mieux gérer l’accès au données certaines entités qui sont très liés possèdent des clés secondaires. Par exemple les entités CdR et Recette, cela va de soit qu’elles sont étroitement liées. Recette possède alors la clé secondaire NomCdR qui est elle-même la clé primaire de CdR.
Dans la même logique nous retrouvons des fonctions principales dans notre code. Nous avons les fonction Client, Créateur de recette et Admin, qui constituent le squelette du code. Les autres fonctions seront des fonctions créées afin d’être appelé dans une de ces trois fonctions, ou sinon elles seront juste créées pour l’interface utilisateur (Démo, accès à la partie Client, CdR ou Admin).
Comme fonctions Client et Créateur de recettes nécessitent une identification ou une création de compte, nous avons créé les fonctions Identification, Inscription ou encore ConnectCompte afin de ne pas surcharger les fonctions principales et faciliter la relecture de code et le débogage si besoin. La structure des fonctions est globalement la même. On demande à l’utilisateur de se connecter, on crée une connexion avec la base de données et on vérifie les informations, si elles sont fausses l’utilisateur peut retenter de se connecter ou il peut s’inscrire, puis on lui propose un choix d’action qui sera géré par un switch dans notre code et une fois l’information récupéré le code exécutera l’action demandé et un retour sera fait à l’utilisateur. Dans la fonction on retrouve presque la même structure. Ce qui diffère c’est qu’il n’y a pas besoin de passer par une phase d’authentification donc nous avons créé aucune classe supplémentaire et toutes les actions à exécuter de la partie administrateur tiennent dans la fonction Admin.
Même si le code est long, avec plus de 1100 lignes, il n’est pas très complexe car la méthode et la structure utilisée sont les mêmes. Ouvrir une connexion, créer un reader, fermer la connexion et le reader après chaque utilisation sont des tâches simples mais qui sont nombreuses. Nous avons dû en ouvrir pas loin d’une dizaine et à chaque fois ce qui changeait était simplement la requête sql et le traitement de l’information récupéré. De plus, le code aurait pu être plus optimisé car de nombreuses variables ont été créé juste pour effectuer une action (compteur, index) et aurait pu être réutilisé mais on se perdait un peu dans le code quand on essayait de retrouver l’ancien compteur en question et ça pouvait nous couper dans notre élan. Donc c’est facilité que nous avons créé plusieurs variables à des endroits différents au lieu d’utiliser les mêmes variables pour tout le code.
C’est un projet intéressant qui nous en apprend beaucoup sur la gestion, l’accès et les requêtes des données.